name: Reusable Docker Blue-Green Deployment

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: string
      container_prefix:
        description: 'Container name prefix'
        required: true
        type: string
      container_port:
        description: 'Container port'
        required: false
        default: '3000'
        type: string
      health_check_timeout:
        description: 'Health check timeout in seconds'
        required: false
        default: '300'
        type: string
      notification_enabled:
        description: 'Enable deployment notifications'
        required: false
        default: true
        type: boolean
    secrets:
      CLOUDFLARE_TUNNEL_TOKEN:
        description: 'Cloudflare tunnel token'
        required: true
      EMAIL_USER:
        description: 'Email user for notifications'
        required: false
      EMAIL_PASS:
        description: 'Email password for notifications'
        required: false

jobs:
  deploy:
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    concurrency:
      group: deploy-${{ inputs.environment }}
      cancel-in-progress: false
    
    env:
      CLOUDFLARED_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
      EMAIL_USER: ${{ secrets.EMAIL_USER }}
      EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
      CONTAINER_PREFIX: ${{ inputs.container_prefix }}
      CONTAINER_PORT: ${{ inputs.container_port }}
    
    outputs:
      deployment_status: ${{ steps.deployment_result.outputs.status }}
      deployed_slot: ${{ steps.determine_slots.outputs.deploy_slot }}
      deployment_time: ${{ steps.deployment_result.outputs.time }}
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
    
    - name: üê≥ Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
    
    - name: üîß Setup Docker Compose Cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.docker/cli-plugins/docker-compose
          /tmp/.buildx-cache
        key: ${{ runner.os }}-docker-${{ hashFiles('**/docker-compose.yml') }}
        restore-keys: |
          ${{ runner.os }}-docker-
    
    - name: üìã Pre-deployment Validation
      id: validation
      run: |
        echo "üîç Validating deployment environment..."
        
        # Check if required files exist
        if [ ! -f "docker-compose.yml" ]; then
          echo "‚ùå docker-compose.yml not found!"
          exit 1
        fi
        
        # Check if Docker daemon is running
        if ! docker info >/dev/null 2>&1; then
          echo "‚ùå Docker daemon is not running!"
          exit 1
        fi
        
        echo "‚úÖ Pre-deployment validation passed"
        echo "validated=true" >> $GITHUB_OUTPUT
    
    - name: üßπ Clean Up Orphaned Containers (Safe)
      run: |
        echo "üßπ Safely cleaning up orphaned containers..."
        
        # Only remove containers that are not currently serving traffic
        # Check which environment is currently active
        if [ -f active_upstream.conf ]; then
          if grep -q "blue" active_upstream.conf; then
            ACTIVE_SLOT="blue"
            STANDBY_SLOT="green"
          else
            ACTIVE_SLOT="green"
            STANDBY_SLOT="blue"
          fi
          
          echo "üîµ Active slot: ${ACTIVE_SLOT}"
          echo "üü¢ Standby slot: ${STANDBY_SLOT}"
          
          # Only remove the standby slot container if it exists and is not healthy
          STANDBY_CONTAINER="${{ env.CONTAINER_PREFIX }}-${STANDBY_SLOT}"
          if docker ps -q -f name="${STANDBY_CONTAINER}" | grep -q .; then
            HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${STANDBY_CONTAINER} 2>/dev/null || echo "none")
            if [ "${HEALTH_STATUS}" != "healthy" ]; then
              echo "üõë Removing unhealthy standby container: ${STANDBY_CONTAINER}"
              docker rm -f ${STANDBY_CONTAINER} 2>/dev/null || true
            else
              echo "‚úÖ Keeping healthy standby container: ${STANDBY_CONTAINER}"
            fi
          fi
        else
          echo "‚ö†Ô∏è No active_upstream.conf found, performing minimal cleanup"
          # Only remove containers that are not running or healthy
          for container in daniel-koryat-portfolio-blue daniel-koryat-portfolio-green; do
            if docker ps -q -f name="${container}" | grep -q .; then
              HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${container} 2>/dev/null || echo "none")
              if [ "${HEALTH_STATUS}" != "healthy" ]; then
                echo "üõë Removing unhealthy container: ${container}"
                docker rm -f ${container} 2>/dev/null || true
              else
                echo "‚úÖ Keeping healthy container: ${container}"
              fi
            fi
          done
        fi
        
        # Clean up any dangling containers (not affecting running services)
        docker container prune -f
        
        echo "‚úÖ Safe cleanup completed"
    
    - name: üîß Create Initial Upstream Config
      run: |
        if [ ! -f active_upstream.conf ]; then
          echo "Creating initial active_upstream.conf, pointing to blue..."
          echo "set \$active_upstream ${{ env.CONTAINER_PREFIX }}-blue:${{ env.CONTAINER_PORT }};" > active_upstream.conf
        fi
    
    - name: üåê Ensure Core Infrastructure
      run: |
        echo "üöÄ Ensuring nginx and cloudflared are running..."
        docker compose up -d --remove-orphans nginx
        
        # Enhanced health check with timeout
        timeout_seconds=60
        elapsed=0
        
        while [ $elapsed -lt $timeout_seconds ]; do
          HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' portfolio-nginx 2>/dev/null || echo "starting")
          if [ "${HEALTH_STATUS}" == "healthy" ]; then
            echo "‚úÖ Nginx is healthy!"
            docker compose up -d --remove-orphans cloudflared
            break
          fi
          echo "‚è≥ Waiting for Nginx to be healthy... (Status: ${HEALTH_STATUS})"
          sleep 6
          elapsed=$((elapsed + 6))
        done
        
        if [ $elapsed -ge $timeout_seconds ]; then
          echo "‚ùå Nginx failed to start within timeout. Check logs."
          docker compose logs nginx
          exit 1
        fi
    
    - name: üéØ Determine Deployment Slots
      id: determine_slots
      run: |
        if grep -q "blue" active_upstream.conf; then
          LIVE_SLOT="blue"
          DEPLOY_SLOT="green"
        else
          LIVE_SLOT="green"
          DEPLOY_SLOT="blue"
        fi
        
        echo "üîµ Live environment: ${LIVE_SLOT}"
        echo "üü¢ Deploying to: ${DEPLOY_SLOT}"
        
        echo "LIVE_SLOT=${LIVE_SLOT}" >> $GITHUB_ENV
        echo "DEPLOY_SLOT=${DEPLOY_SLOT}" >> $GITHUB_ENV
        echo "live_slot=${LIVE_SLOT}" >> $GITHUB_OUTPUT
        echo "deploy_slot=${DEPLOY_SLOT}" >> $GITHUB_OUTPUT
    
    - name: üîç Validate Live Environment Health
      run: |
        LIVE_CONTAINER="${{ env.CONTAINER_PREFIX }}-${{ env.LIVE_SLOT }}"
        echo "üîç Validating live environment health: ${LIVE_CONTAINER}"
        
        # Check if live container exists and is healthy
        if ! docker ps -q -f name="${LIVE_CONTAINER}" | grep -q .; then
          echo "‚ùå Live container ${LIVE_CONTAINER} is not running!"
          echo "üöÄ Starting live container..."
          docker compose up -d --remove-orphans "${LIVE_CONTAINER}"
          
          # Wait for it to become healthy
          timeout_seconds=120
          elapsed=0
          while [ $elapsed -lt $timeout_seconds ]; do
            HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${LIVE_CONTAINER} 2>/dev/null || echo "starting")
            if [ "${HEALTH_STATUS}" == "healthy" ]; then
              echo "‚úÖ Live container is now healthy!"
              break
            fi
            echo "‚è≥ Waiting for live container to be healthy... (Status: ${HEALTH_STATUS})"
            sleep 10
            elapsed=$((elapsed + 10))
          done
          
          if [ $elapsed -ge $timeout_seconds ]; then
            echo "‚ùå Live container failed to become healthy. Aborting deployment."
            exit 1
          fi
        else
          HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${LIVE_CONTAINER} 2>/dev/null || echo "none")
          if [ "${HEALTH_STATUS}" != "healthy" ]; then
            echo "‚ùå Live container ${LIVE_CONTAINER} is not healthy (Status: ${HEALTH_STATUS})"
            echo "üîÑ Attempting to restart live container..."
            docker restart ${LIVE_CONTAINER}
            
            # Wait for it to become healthy
            timeout_seconds=120
            elapsed=0
            while [ $elapsed -lt $timeout_seconds ]; do
              HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${LIVE_CONTAINER} 2>/dev/null || echo "starting")
              if [ "${HEALTH_STATUS}" == "healthy" ]; then
                echo "‚úÖ Live container is now healthy!"
                break
              fi
              echo "‚è≥ Waiting for live container to be healthy... (Status: ${HEALTH_STATUS})"
              sleep 10
              elapsed=$((elapsed + 10))
            done
            
            if [ $elapsed -ge $timeout_seconds ]; then
              echo "‚ùå Live container failed to become healthy. Aborting deployment."
              exit 1
            fi
          else
            echo "‚úÖ Live container is healthy!"
          fi
        fi
    
    - name: üî® Build and Deploy New Version
      run: |
        echo "üöÄ Building and deploying ${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}..."
        
        # Build with cache
        DOCKER_BUILDKIT=1 docker compose build --build-arg BUILDKIT_INLINE_CACHE=1 "${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
        
        # Deploy the new version with orphan removal
        docker compose up -d --force-recreate --remove-orphans "${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
    
    - name: üîç Wait for New Environment Health
      run: |
        CONTAINER_NAME="${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
        timeout_seconds=${{ inputs.health_check_timeout }}
        elapsed=0
        
        echo "üîç Waiting for ${CONTAINER_NAME} to become healthy..."
        
        while [ $elapsed -lt $timeout_seconds ]; do
          HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "starting")
          if [ "${HEALTH_STATUS}" == "healthy" ]; then
            echo "‚úÖ ${CONTAINER_NAME} is healthy!"
            break
          fi
          echo "‚è≥ Waiting... (Status: ${HEALTH_STATUS}) - ${elapsed}s elapsed"
          sleep 10
          elapsed=$((elapsed + 10))
        done
        
        if [ $elapsed -ge $timeout_seconds ]; then
          echo "‚ùå ${CONTAINER_NAME} failed to become healthy. Aborting."
          docker compose logs "${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
          exit 1
        fi
    
    - name: üîÑ Switch Traffic (Zero Downtime)
      run: |
        echo "üîÑ Switching traffic from ${{ env.LIVE_SLOT }} to ${{ env.DEPLOY_SLOT }}..."
        
        # Backup current config
        cp active_upstream.conf active_upstream.conf.backup
        
        # Create a temporary config with both upstreams for smooth transition
        echo "set \$active_upstream ${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}:${{ env.CONTAINER_PORT }};" > active_upstream.conf.tmp
        echo "set \$backup_upstream ${{ env.CONTAINER_PREFIX }}-${{ env.LIVE_SLOT }}:${{ env.CONTAINER_PORT }};" >> active_upstream.conf.tmp
        
        # Atomically switch the upstream
        mv active_upstream.conf.tmp active_upstream.conf
        
        # Perform graceful nginx reload with connection draining
        echo "üîÑ Performing graceful nginx reload with connection draining..."
        
        # Send SIGUSR1 to nginx for graceful reload (drains existing connections)
        docker compose exec nginx nginx -s reload
        
        # Wait a moment for connections to drain
        echo "‚è≥ Waiting for connections to drain..."
        sleep 5
        
        # Verify the new environment is still healthy after traffic switch
        NEW_CONTAINER="${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
        HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${NEW_CONTAINER} 2>/dev/null || echo "none")
        
        if [ "${HEALTH_STATUS}" == "healthy" ]; then
          echo "‚úÖ Traffic switched successfully! New environment is healthy."
        else
          echo "‚ùå New environment is not healthy after traffic switch. Rolling back..."
          
          # Rollback to previous configuration
          mv active_upstream.conf.backup active_upstream.conf
          docker compose exec nginx nginx -s reload
          
          echo "‚ùå Deployment failed - rolled back to previous environment"
          exit 1
        fi
    
    - name: üßπ Clean Up Old Environment
      run: |
        echo "üõë Stopping the old ${{ env.LIVE_SLOT }} container..."
        docker compose stop "${{ env.CONTAINER_PREFIX }}-${{ env.LIVE_SLOT }}" || true
        
        # Clean up old images (keep last 2 versions)
        docker image prune -f --filter "until=72h" || true
    
    - name: üîç Final Deployment Validation
      run: |
        echo "üîç Performing final deployment validation..."
        
        # Verify the new environment is still healthy
        NEW_CONTAINER="${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
        HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${NEW_CONTAINER} 2>/dev/null || echo "none")
        
        if [ "${HEALTH_STATUS}" != "healthy" ]; then
          echo "‚ùå Final validation failed - new environment is not healthy"
          echo "üîÑ Rolling back to previous environment..."
          
          # Rollback to previous configuration
          if [ -f active_upstream.conf.backup ]; then
            mv active_upstream.conf.backup active_upstream.conf
            docker compose exec nginx nginx -s reload
            echo "‚úÖ Rollback completed"
          fi
          
          exit 1
        fi
        
        # Verify nginx is serving traffic correctly
        NGINX_STATUS=$(docker inspect --format '{{.State.Health.Status}}' portfolio-nginx 2>/dev/null || echo "none")
        if [ "${NGINX_STATUS}" != "healthy" ]; then
          echo "‚ùå Final validation failed - nginx is not healthy"
          exit 1
        fi
        
        echo "‚úÖ Final validation passed - deployment successful!"
    
    - name: üìä Deployment Summary
      id: deployment_result
      run: |
        echo "üéâ Zero-downtime deployment complete!"
        echo "üìà Deployment Summary:"
        echo "  ‚Ä¢ Environment: ${{ inputs.environment }}"
        echo "  ‚Ä¢ Deployed Slot: ${{ env.DEPLOY_SLOT }}"
        echo "  ‚Ä¢ Previous Slot: ${{ env.LIVE_SLOT }}"
        echo "  ‚Ä¢ Container: ${{ env.CONTAINER_PREFIX }}-${{ env.DEPLOY_SLOT }}"
        echo "  ‚Ä¢ Time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        
        docker compose ps
        
        echo "status=success" >> $GITHUB_OUTPUT
        echo "time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
    
    - name: üìß Send Notification
      if: ${{ inputs.notification_enabled && always() }}
      run: |
        if [ "${{ steps.deployment_result.outputs.status }}" = "success" ]; then
          STATUS_EMOJI="‚úÖ"
          STATUS_TEXT="SUCCESS"
        else
          STATUS_EMOJI="‚ùå"
          STATUS_TEXT="FAILED"
        fi
        
        echo "${STATUS_EMOJI} Deployment ${STATUS_TEXT} for ${{ inputs.environment }}"
        echo "Slot: ${{ env.DEPLOY_SLOT }}"
        echo "Time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
